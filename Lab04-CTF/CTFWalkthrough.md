2. Given the fact that the given string is a weird string that doesn't correspond to English, plus the fact that there is an expanded alphabet being used (upper and lowercase letters, plus 0-9), I can safely assume that this is probably base64 (and the hint confirms this). You do need to understand the encoding used for the string. I found a [base64 decoder](https://onlineasciitools.com/convert-ascii-to-base64) and plugged the given string in the base64 slot, and got it to convert to the correct answer.
3. Given the fact that the downloaded file is an image, this means that the answer is probably hidden within the image file. As a PNG file is encoded in binary, we can use a command line tool like xxd to read the image file and have both the hex data and decoded binary text print in stdout. Combine this with grep THM and arg -A 3 (as idk how many lines later the answer will be), and we get our answer.
4. I wasn't too sure what was up with this, so I checked the hint and it was Steghide. From my research, this is a stenography tool that allows data to be hidden within an innocent file through AES encryption, meaning that any programs that I made for decrypting is useless (as they're more for the old days when computers weren't that around). I searched up for a [Steghide decoder](https://futureboy.us/stegano/decinput.html), uploaded the file in question, left the password blank, and used the view raw output as MIME-type text/plain option and got the answer string.
5. Turns out I didn't realize that all I needed to do was to highlight the text on the Huh where is the flag line, given the hint of highlighting the text or checking the HTML for that area. The answer turned out to be on the line.
6. Too obvious. The downloaded file was a QR code, which I could then scan with my phone's camera app to get the string in question.
7. Similar to task 3, where the string is hidden within the binary data of the image. You can xxd the image and then grep for the THM string with some padding to get your answer.
8. Similar to task 2, but the fact that there are no symbols means that there is a shorter base encoding involved. Given the hint of base58, I used a [base58 decoder](https://www.dcode.fr/base-58-cipher) to decode the string given to the answer.
9. The prompt discusses about Rot13 being too mainstream, so this is probably a RotX string (as the brackets hadn't been mutilated and its only the letters). I used my monocypher from Lab01 to crack the string and got the answer.
10. Turns out I need to break out my browser devtools more often. Given the hint of checking the HTML, I can use the elements inspector to click on the region surrounding the task prompt and find out the answer string that was hidden with the style="display:none" attribute.
11. The prompt of the image file being messed up means that the header is probably messed up. A quick search on the PNG image header and a bit of repair via xxd hex data output to text file, editing the hexdump such that the header is correct, and then using xxd to turn the hex data to proper png data reveals the answer in the image.
12. This question is literally unanswerable without the hint of looking at TryHackMe's reddit account to find the answer. I literally googled "TryHackMe rooms Reddit" and clicked on the first link to find the answer to this question.
13. The syntax used in this question was very reminiscent of Brainfuck (which I heard of from a funny Fireship video on it and knew that it used a combination of plus, minuses, arrows, and dots). I found a [Brainfuck interpreter](https://www.roblox.com/games/8246706503/Brainoof-Interpreter) (or [this](https://sange.fi/esoteric/brainfuck/impl/interp/i.html)) and got the answer.
14. The prompt discusses about exclusive strings, which hints at using XOR operations for each byte to find out what the decoded string actually is. I first pasted both strings into seperate files so that it can be used in my XOR lab, then I used xxd with the -r -p flags to turn the presumed hex filesto binary so that the data can be used in the XOR lab. Then I used the XOR lab to compute the XOR of these two, which returned the answer (plus some garbage data).
15. You will need to know that a file is hidden with binwalk. If you use binwalk, you will be able to use a binwalk tool (brew install binwalk for my M1 Mac) with the downloaded file and -e flag to extract the file that contains the answer.
16. We will need to know that the image hides some visual data and that a tool like stegsolve (the hint) can be used to remove bits off the image to reveal the image data. I used [this tool](https://stegonline.georgeom.net/upload), used the browse bit planes and scrolled through until I got to blue 1, which then revealed the answer.
17. I saw that there was QR code and a hint at listening to the audio, so I scanned it and it sent me to a soundcloud page for me to listen to the audio. It was too fast, so I used a [soundcloud downloader](https://sclouddownloader.net/) to download the audio file and used QuickTime to slow the audio down to half speed and although it was still painful to deal with, I was able to process the audio with relative ease and get the answer.
18. The prompt suggested digging out the past with a targeted website and time, so I used the [Wayback Machine](https://archive.org/), entered the URL and set it to show the page on 1/2/2020 [result](https://web.archive.org/web/20200102131252/https://www.embeddedhacker.com/), and found the flag.
19. The prompt suggests that there was a key involved, but the brackets stayed intact, so this was probably a vigeniere ciphered string. I plugged the string into my vigeniere cipher, but it did not work any way I tried to do it. I decided to use an [online cracker](https://www.dcode.fr/vigenere-cipher), plug in the known plaintext word TRYHACKME and got the answer.
20. The hint suggests converting the given number to a hex ([via this converter](https://www.rapidtables.com/convert/number/decimal-to-hex.html) and then pasting the hex into a file and converting it to ascii via the xxd -p -r command to get the answer.
21. The downloadable file is a pcapng file, meaning that I would probably need to use a pcapng file reader like [this](https://apackets.com/) in order to view the packet content. I uploaded the file into their reader, then clicked on HTTP communication and clicked the second dropdown and the flag was within that GET request log.